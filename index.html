<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Neon 3D Tic-Tac-Toe</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background-color: #000;
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    #root {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      overflow: hidden;
    }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: #000; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #555; }
  </style>
  <script>
    function fixSize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const style = `
        position:fixed!important;
        top:0!important;left:0!important;
        width:${w}px!important;
        height:${h}px!important;
        overflow:hidden!important;
      `;
      document.documentElement.setAttribute('style', `width:${w}px;height:${h}px;overflow:hidden;`);
      document.body.setAttribute('style', `width:${w}px;height:${h}px;overflow:hidden;margin:0;padding:0;`);
      const root = document.getElementById('root');
      if (root) root.setAttribute('style', style);
    }
    // Ricalcola immediatamente e ad ogni cambio
    fixSize();
    window.addEventListener('resize', fixSize);
    window.addEventListener('orientationchange', () => { fixSize(); setTimeout(fixSize, 300); setTimeout(fixSize, 600); });
    document.addEventListener('DOMContentLoaded', fixSize);
    // Osserva il body con ResizeObserver per reagire a qualsiasi cambio (iframe resize, ecc.)
    window.addEventListener('load', () => {
      fixSize();
      if (window.ResizeObserver) {
        new ResizeObserver(fixSize).observe(document.body);
      }
    });
    [100, 300, 600, 1000].forEach(t => setTimeout(fixSize, t));
  </script>
  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "react-dom": "https://esm.sh/react-dom@18.2.0",
      "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,three,@react-three/fiber",
      "three": "https://esm.sh/three@0.160.0",
      "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
      "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
      "maath": "https://esm.sh/maath@0.10.7?external=react,three",
      "framer-motion": "https://esm.sh/framer-motion@11.0.8?external=react,react-dom",
      "react-dom/": "https://esm.sh/react-dom@^18.2.0/",
      "react/": "https://esm.sh/react@^18.2.0/"
    }
  }
  </script>
</head>
<body>
  <div id="root"></div>
  <script type="module">
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import ReactDOM from 'react-dom/client';
import { Canvas, useFrame } from '@react-three/fiber';
import { EffectComposer, Bloom } from '@react-three/postprocessing';
import { Stars, useCursor } from '@react-three/drei';
import { easing } from 'maath';
import { Color, MeshStandardMaterial, Group, Mesh } from 'three';
import { motion, AnimatePresence } from 'framer-motion';
// ─── constants.ts ────────────────────────────────────────────────────────────
const COLORS = {
  X: '#ff003c',
  O: '#00f3ff',
  NEUTRAL: '#2a2a2a',
  WIN: '#ffffff',
  GRID: '#1a1a1a'
};

const BLOOM_SETTINGS = {
  threshold: 0.1,
  strength: 1.5,
  radius: 0.5
};

// ─── types.ts ────────────────────────────────────────────────────────────────
const WINNING_COMBINATIONS = [
  [0, 1, 2], [3, 4, 5], [6, 7, 8],
  [0, 3, 6], [1, 4, 7], [2, 5, 8],
  [0, 4, 8], [2, 4, 6]
];

// ─── useGameLogic.ts ─────────────────────────────────────────────────────────
const useGameLogic = ({ mode, myPlayerRole, onMoveMade }) => {
  const [board, setBoard] = useState(Array(9).fill(null));
  const [currentPlayer, setCurrentPlayer] = useState('X');
  const [winner, setWinner] = useState(null);
  const [winningLine, setWinningLine] = useState(null);

  const checkWinner = (currentBoard) => {
    for (const combo of WINNING_COMBINATIONS) {
      const [a, b, c] = combo;
      if (currentBoard[a] && currentBoard[a] === currentBoard[b] && currentBoard[a] === currentBoard[c]) {
        return { winner: currentBoard[a], line: combo };
      }
    }
    if (!currentBoard.includes(null)) return { winner: 'DRAW', line: null };
    return null;
  };

  const processMove = useCallback((index, player) => {
    setBoard(prev => {
      const newBoard = [...prev];
      newBoard[index] = player;
      const result = checkWinner(newBoard);
      setTimeout(() => {
        if (result) {
          setWinner(result.winner);
          setWinningLine(result.line);
        } else {
          setCurrentPlayer(player === 'X' ? 'O' : 'X');
        }
      }, 0);
      return newBoard;
    });
  }, []);

  const makeMove = useCallback((index) => {
    if (board[index] || winner) return;
    if (mode === 'ONLINE' && currentPlayer !== myPlayerRole) return;
    if (mode === 'BOT' && currentPlayer === 'O') return;
    processMove(index, currentPlayer);
    if (onMoveMade) onMoveMade(index);
  }, [board, currentPlayer, winner, mode, myPlayerRole, onMoveMade, processMove]);

  useEffect(() => {
    if (mode === 'BOT' && currentPlayer === 'O' && !winner) {
      const timeout = setTimeout(() => {
        const emptyIndices = board.map((val, idx) => val === null ? idx : null).filter(val => val !== null);
        if (emptyIndices.length > 0) {
          const randomIndex = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
          processMove(randomIndex, 'O');
        }
      }, 600);
      return () => clearTimeout(timeout);
    }
  }, [mode, currentPlayer, winner, board, processMove]);

  const resetGame = useCallback(() => {
    setBoard(Array(9).fill(null));
    setCurrentPlayer('X');
    setWinner(null);
    setWinningLine(null);
  }, []);

  const networkMove = useCallback((index) => {
    const otherPlayer = myPlayerRole === 'X' ? 'O' : 'X';
    processMove(index, otherPlayer);
  }, [myPlayerRole, processMove]);

  return { board, currentPlayer, winner, winningLine, makeMove, networkMove, resetGame };
};

// ─── useMultiplayer.ts (WebRTC nativo — zero account, zero server) ────────────
const ICE_SERVERS = { iceServers: [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
] };

const useMultiplayer = () => {
  const [peerId, setPeerId]           = useState(null);       // offerta base64 (host) oppure null
  const [answerCode, setAnswerCode]   = useState(null);       // risposta base64 (guest)
  const [connection, setConnection]   = useState(null);       // oggetto canale con .send() e .on('data')
  const [isConnected, setIsConnected] = useState(false);
  const [isHost, setIsHost]           = useState(false);
  const [error, setError]             = useState(null);
  const pcRef      = useRef(null);
  const channelRef = useRef(null);
  const listenersRef = useRef({});   // { data: fn, close: fn }

  const destroy = useCallback(() => {
    if (channelRef.current) { channelRef.current.close(); channelRef.current = null; }
    if (pcRef.current)      { pcRef.current.close();      pcRef.current = null; }
  }, []);

  // Oggetto "connection" compatibile con il vecchio codice (conn.on / conn.off / conn.send)
  const makeConn = useCallback((ch) => {
    channelRef.current = ch;
    const conn = {
      send: (msg) => { if (ch.readyState === 'open') ch.send(JSON.stringify(msg)); },
      on:  (ev, fn) => { listenersRef.current[ev] = fn; },
      off: (ev)     => { delete listenersRef.current[ev]; },
    };
    ch.onmessage = (e) => {
      try { const msg = JSON.parse(e.data); listenersRef.current['data']?.(msg); } catch {}
    };
    ch.onclose = () => {
      setIsConnected(false);
      setConnection(null);
      listenersRef.current['close']?.();
      setError('Connessione Persa');
    };
    ch.onopen = () => { setIsConnected(true); setConnection(conn); setError(null); };
    return conn;
  }, []);

  const gatherIce = (pc) => new Promise(resolve => {
    if (pc.iceGatheringState === 'complete') { resolve(); return; }
    pc.onicegatheringstatechange = () => { if (pc.iceGatheringState === 'complete') resolve(); };
    setTimeout(resolve, 5000);   // fallback 5s
  });

  // HOST: genera offerta → peerId conterrà la stringa da mandare al guest
  const createGroup = useCallback(async () => {
    destroy();
    setError(null); setIsHost(true); setIsConnected(false); setPeerId(null); setAnswerCode(null);
    const pc = new RTCPeerConnection(ICE_SERVERS);
    pcRef.current = pc;
    const ch = pc.createDataChannel('game', { ordered: true });
    makeConn(ch);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await gatherIce(pc);
    setPeerId(btoa(JSON.stringify(pc.localDescription)));
  }, [destroy, makeConn]);

  // HOST: accetta la risposta del guest (chiamata da MainMenu quando l'host incolla il codice)
  const acceptAnswer = useCallback(async (raw) => {
    try {
      const answer = JSON.parse(atob(raw.trim()));
      await pcRef.current.setRemoteDescription(answer);
    } catch { setError('Codice risposta non valido.'); }
  }, []);

  // GUEST: riceve offerta → genera risposta → answerCode conterrà la stringa da rimandare
  const joinGroup = useCallback(async (raw) => {
    destroy();
    setError(null); setIsHost(false); setIsConnected(false); setAnswerCode(null);
    try {
      const offer = JSON.parse(atob(raw.trim()));
      const pc = new RTCPeerConnection(ICE_SERVERS);
      pcRef.current = pc;
      pc.ondatachannel = (ev) => makeConn(ev.channel);
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await gatherIce(pc);
      setAnswerCode(btoa(JSON.stringify(pc.localDescription)));
    } catch { setError('Codice offerta non valido.'); }
  }, [destroy, makeConn]);

  const sendMessage = useCallback((msg) => {
    if (connection && isConnected) connection.send(msg);
  }, [connection, isConnected]);

  useEffect(() => () => destroy(), [destroy]);

  return { peerId, answerCode, isConnected, isHost, error, connection, createGroup, joinGroup, acceptAnswer, sendMessage };
};

// ─── CameraController.tsx ────────────────────────────────────────────────────
const CameraController = ({ currentPlayer, winner }) => {
  const angleRef = useRef({ value: 0 });
  const radius = 12;
  const height = 6;

  useFrame((state, delta) => {
    if (winner) {
      angleRef.current.value += delta * 0.5;
    } else {
      const targetAngle = currentPlayer === 'X' ? 0 : Math.PI;
      easing.damp(angleRef.current, 'value', targetAngle, 0.5, delta);
    }
    const theta = angleRef.current.value;
    const x = radius * Math.sin(theta);
    const z = radius * Math.cos(theta);
    state.camera.position.set(x, height, z);
    state.camera.lookAt(0, 0, 0);
  });

  return null;
};

// ─── NeonBoard.tsx ───────────────────────────────────────────────────────────
const NeonBoard = ({ currentPlayer, winner }) => {
  const neonMaterial = useMemo(() => {
    return new MeshStandardMaterial({
      color: "#000000",
      roughness: 0.1,
      metalness: 0.8,
      toneMapped: false,
      emissive: new Color("#000000"),
      emissiveIntensity: 1
    });
  }, []);

  useEffect(() => { return () => neonMaterial.dispose(); }, [neonMaterial]);

  useFrame((state, delta) => {
    let targetColor = COLORS.GRID;
    let emissiveIntensity = 1;
    if (winner) {
      targetColor = COLORS.WIN;
      emissiveIntensity = 0.5;
    } else {
      targetColor = currentPlayer === 'X' ? COLORS.X : COLORS.O;
      emissiveIntensity = 2;
    }
    easing.dampC(neonMaterial.emissive, targetColor, 0.2, delta);
    easing.damp(neonMaterial, 'emissiveIntensity', emissiveIntensity, 0.2, delta);
  });

  const thickness = 0.15;
  const length = 6.5;
  const spacing = 1.1;

  return React.createElement('group', null,
    React.createElement('mesh', { position: [-spacing, 0, 0], receiveShadow: true, castShadow: true, material: neonMaterial },
      React.createElement('boxGeometry', { args: [thickness, thickness, length] })
    ),
    React.createElement('mesh', { position: [spacing, 0, 0], receiveShadow: true, castShadow: true, material: neonMaterial },
      React.createElement('boxGeometry', { args: [thickness, thickness, length] })
    ),
    React.createElement('mesh', { position: [0, 0, -spacing], receiveShadow: true, castShadow: true, material: neonMaterial },
      React.createElement('boxGeometry', { args: [length, thickness, thickness] })
    ),
    React.createElement('mesh', { position: [0, 0, spacing], receiveShadow: true, castShadow: true, material: neonMaterial },
      React.createElement('boxGeometry', { args: [length, thickness, thickness] })
    )
  );
};

// ─── Pieces.tsx ──────────────────────────────────────────────────────────────
const PieceX = ({ position, isWinningPiece, gameEnded }) => {
  const groupRef = useRef(null);

  useFrame((state, delta) => {
    if (groupRef.current) {
      const time = state.clock.elapsedTime;
      const bobbing = Math.sin(time * 2) * 0.1;
      const sway = Math.sin(time * 1.5) * 0.15;
      let targetScale = 0.8;
      let targetY = position[1] + bobbing;
      let targetRotationY = sway;
      if (gameEnded) {
        if (isWinningPiece) {
          const pulse = Math.sin(time * 8) * 0.1;
          targetScale = 1.1 + pulse;
          targetY = position[1] + 0.5;
          targetRotationY = Math.sin(time * 1.0) * 0.2;
        } else {
          targetScale = 0.01;
          targetY = position[1];
        }
      }
      easing.damp3(groupRef.current.scale, [targetScale, targetScale, targetScale], 0.3, delta);
      easing.damp(groupRef.current.position, 'y', targetY, 0.3, delta);
      easing.damp(groupRef.current.rotation, 'y', targetRotationY, 0.3, delta);
    }
  });

  const barDimensions = [3, 0.2, 0.2];
  const intensity = gameEnded && isWinningPiece ? 8 : 3;

  return React.createElement('group', { ref: groupRef, position },
    React.createElement('mesh', { rotation: [0, Math.PI / 4, 0] },
      React.createElement('boxGeometry', { args: barDimensions }),
      React.createElement('meshStandardMaterial', { color: "#000000", emissive: COLORS.X, emissiveIntensity: intensity, toneMapped: false })
    ),
    React.createElement('mesh', { rotation: [0, -Math.PI / 4, 0] },
      React.createElement('boxGeometry', { args: barDimensions }),
      React.createElement('meshStandardMaterial', { color: "#000000", emissive: COLORS.X, emissiveIntensity: intensity, toneMapped: false })
    )
  );
};

const PieceO = ({ position, isWinningPiece, gameEnded }) => {
  const meshRef = useRef(null);

  useFrame((state, delta) => {
    if (meshRef.current) {
      let targetScale = 0.8;
      let targetY = position[1];
      const bobbing = Math.sin(state.clock.elapsedTime * 2) * 0.1;
      if (gameEnded) {
        if (isWinningPiece) {
          targetScale = 1.1;
          targetY = position[1] + 0.5;
          meshRef.current.rotation.x += delta * 2;
          meshRef.current.rotation.y += delta * 2;
        } else {
          targetScale = 0.1;
        }
      } else {
        targetY = position[1] + bobbing;
      }
      easing.damp3(meshRef.current.scale, [targetScale, targetScale, targetScale], 0.3, delta);
      easing.damp(meshRef.current.position, 'y', targetY, 0.3, delta);
    }
  });

  const intensity = gameEnded && isWinningPiece ? 8 : 3;

  return React.createElement('mesh', { ref: meshRef, position, rotation: [Math.PI / 2, 0, 0], scale: [0, 0, 0] },
    React.createElement('torusGeometry', { args: [1, 0.15, 16, 32] }),
    React.createElement('meshStandardMaterial', { color: "#000000", emissive: COLORS.O, emissiveIntensity: intensity, toneMapped: false })
  );
};

// ─── InteractionPlane.tsx ────────────────────────────────────────────────────
const InteractionPlane = ({ index, onClick, disabled }) => {
  const [hovered, setHover] = useState(false);
  useCursor(hovered && !disabled);

  const spacing = 2.2;
  const col = (index % 3) - 1;
  const row = Math.floor(index / 3) - 1;
  const x = col * spacing;
  const z = row * spacing;

  return React.createElement('mesh', {
    position: [x, 0.1, z],
    rotation: [-Math.PI / 2, 0, 0],
    onClick: (e) => { e.stopPropagation(); if (!disabled) onClick(index); },
    onPointerOver: () => setHover(true),
    onPointerOut: () => setHover(false)
  },
    React.createElement('planeGeometry', { args: [2, 2] }),
    React.createElement('meshBasicMaterial', {
      color: "white",
      opacity: hovered && !disabled ? 0.1 : 0.0,
      transparent: true,
      depthWrite: false
    })
  );
};

// ─── GameScene.tsx ───────────────────────────────────────────────────────────
const GameScene = ({ game }) => {
  const { board, currentPlayer, winner, winningLine, makeMove } = game;

  const getPosition = (index) => {
    const spacing = 2.2;
    const col = (index % 3) - 1;
    const row = Math.floor(index / 3) - 1;
    return [col * spacing, 0, row * spacing];
  };

  const isWinningPiece = (index) => winningLine?.includes(index) ?? false;

  return React.createElement(Canvas, {
    shadows: true,
    camera: { position: [0, 6, 12], fov: 45 },
    gl: { antialias: false }
  },
    React.createElement('color', { attach: "background", args: ['#000000'] }),
    React.createElement('ambientLight', { intensity: 0.5 }),
    React.createElement('pointLight', { position: [10, 10, 10], intensity: 1 }),
    React.createElement(Stars, { radius: 100, depth: 50, count: 5000, factor: 4, saturation: 0, fade: true, speed: 1 }),
    React.createElement(CameraController, { currentPlayer, winner }),
    React.createElement(NeonBoard, { currentPlayer, winner }),
    ...board.map((cell, index) => {
      if (cell === 'X') return React.createElement(PieceX, { key: index, position: getPosition(index), isWinningPiece: isWinningPiece(index), gameEnded: !!winner });
      if (cell === 'O') return React.createElement(PieceO, { key: index, position: getPosition(index), isWinningPiece: isWinningPiece(index), gameEnded: !!winner });
      return null;
    }),
    ...board.map((cell, index) =>
      React.createElement(InteractionPlane, { key: `plane-${index}`, index, onClick: makeMove, disabled: !!cell || !!winner })
    ),
    React.createElement(EffectComposer, { disableNormalPass: true },
      React.createElement(Bloom, { luminanceThreshold: BLOOM_SETTINGS.threshold, mipmapBlur: true, intensity: BLOOM_SETTINGS.strength, radius: BLOOM_SETTINGS.radius })
    )
  );
};

// ─── UIOverlay.tsx ───────────────────────────────────────────────────────────
const UIOverlay = ({ winner, currentPlayer, onReset }) => {
  const winText = winner === 'DRAW' ? 'SYSTEM FAILURE' : `PLAYER ${winner} WINS`;
  const winColor = winner === 'X' ? COLORS.X : winner === 'O' ? COLORS.O : '#ffffff';

  return React.createElement('div', {
    className: "absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between p-4 md:p-8",
    style: { fontFamily: "'Orbitron', sans-serif" }
  },
    React.createElement('style', null, `
      .glitch-wrapper { position: relative; }
      .glitch { position: relative; color: ${winColor}; font-weight: 900; letter-spacing: 0.1em; text-transform: uppercase; }
      .glitch::before, .glitch::after { content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; }
      .glitch::before { left: 2px; text-shadow: -2px 0 #ff00c1; clip-path: inset(44% 0 61% 0); animation: glitch-anim-1 2s infinite linear alternate-reverse; }
      .glitch::after { left: -2px; text-shadow: -2px 0 #00fff9; clip-path: inset(50% 0 30% 0); animation: glitch-anim-2 2.5s infinite linear alternate-reverse; }
      @keyframes glitch-anim-1 { 0% { clip-path: inset(20% 0 80% 0); } 20% { clip-path: inset(60% 0 10% 0); } 40% { clip-path: inset(40% 0 50% 0); } 60% { clip-path: inset(80% 0 5% 0); } 80% { clip-path: inset(10% 0 70% 0); } 100% { clip-path: inset(30% 0 20% 0); } }
      @keyframes glitch-anim-2 { 0% { clip-path: inset(10% 0 60% 0); } 20% { clip-path: inset(30% 0 10% 0); } 40% { clip-path: inset(70% 0 20% 0); } 60% { clip-path: inset(20% 0 50% 0); } 80% { clip-path: inset(50% 0 40% 0); } 100% { clip-path: inset(0% 0 80% 0); } }
      .scanline { width: 100%; height: 2px; background: rgba(255,255,255,0.1); animation: scanline 6s linear infinite; }
      @keyframes scanline { 0% { transform: translateY(-100vh); } 100% { transform: translateY(100vh); } }
      @keyframes animate-in { from { opacity: 0; } to { opacity: 1; } }
      @keyframes zoom-in-95 { from { transform: scale(0.95); } to { transform: scale(1); } }
      .fade-in { animation: animate-in 0.5s ease forwards; }
      .zoom-in-95 { animation: zoom-in-95 0.3s ease forwards; }
    `),

    // Header
    React.createElement('div', { className: "flex flex-col md:flex-row justify-between items-start md:items-center z-10 gap-4 md:gap-0" },
      React.createElement('div', { className: "pr-8 md:pr-0" },
        React.createElement('h1', {
          className: "text-3xl md:text-5xl font-black text-white italic tracking-tighter leading-tight pr-4 py-2",
          style: { textShadow: '0 0 10px rgba(255,255,255,0.8)' }
        },
          'NEON',
          React.createElement('span', {
            className: "text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 pr-4"
          }, 'TRIS')
        ),
        React.createElement('div', { className: "h-1 w-full bg-gradient-to-r from-white to-transparent mt-1" })
      ),
      React.createElement('div', { className: "relative group self-end md:self-auto" },
        React.createElement('div', { className: "absolute -inset-1 bg-gradient-to-r from-pink-600 to-blue-600 rounded-lg blur opacity-25 group-hover:opacity-75 transition duration-1000 group-hover:duration-200" }),
        React.createElement('div', { className: "relative bg-black border border-white/10 px-6 py-2 rounded-lg flex items-center gap-3" },
          React.createElement('span', { className: "text-xs text-gray-500 font-bold tracking-widest" }, 'CURRENT_LINK::'),
          React.createElement('span', {
            className: "text-2xl font-bold",
            style: { color: currentPlayer === 'X' ? COLORS.X : COLORS.O, textShadow: `0 0 15px ${currentPlayer === 'X' ? COLORS.X : COLORS.O}` }
          }, currentPlayer)
        )
      )
    ),

    // Game Over Modal
    winner && React.createElement('div', {
      className: "absolute inset-0 flex flex-col items-center justify-center bg-black/90 backdrop-blur-sm pointer-events-auto z-50 fade-in p-4"
    },
      React.createElement('div', { className: "absolute inset-0 overflow-hidden pointer-events-none opacity-20" },
        React.createElement('div', { className: "scanline" })
      ),
      React.createElement('div', { className: "text-center relative z-10 zoom-in-95 max-w-full" },
        React.createElement('div', { className: "mb-4 text-xs tracking-[0.5em] text-gray-500 uppercase" }, 'Game Sequence Terminated'),
        React.createElement('div', { className: "glitch-wrapper mb-8" },
          React.createElement('h2', {
            className: "text-5xl md:text-9xl glitch break-words",
            'data-text': winText,
            style: { textShadow: `0 0 30px ${winColor}80` }
          }, winText)
        ),
        React.createElement('button', { onClick: onReset, className: "group relative px-8 py-4 bg-transparent" },
          React.createElement('div', { className: "absolute inset-0 w-3 bg-white transition-all duration-[250ms] ease-out group-hover:w-full opacity-10" }),
          React.createElement('div', { className: "absolute inset-0 border-2 border-white transform skew-x-12 group-hover:skew-x-0 transition-transform duration-300" }),
          React.createElement('span', { className: "relative text-xl font-bold tracking-widest text-white group-hover:text-cyan-400 transition-colors duration-300" }, 'REBOOT_SYSTEM')
        )
      )
    ),

    // Footer
    React.createElement('div', { className: "flex justify-between items-end text-xs text-gray-600 font-mono pointer-events-auto w-full border-t border-gray-900 pt-4" },
      React.createElement('div', null, 'SYS.VER.2.0.77'),
      React.createElement('div', { className: "animate-pulse" }, 'WAITING_FOR_INPUT...')
    )
  );
};

// ─── IntroLogo.tsx ───────────────────────────────────────────────────────────
const IntroLogo = () => {
  const container = {
    hidden: { opacity: 0 },
    show: { opacity: 1, transition: { staggerChildren: 0.1, delayChildren: 0.3 } }
  };
  const item = {
    hidden: { y: 20, opacity: 0, scale: 0.8 },
    show: { y: 0, opacity: 1, scale: 1, transition: { type: "spring", stiffness: 100 } }
  };

  return React.createElement('div', { className: "flex flex-col items-center justify-center mb-12 relative z-20" },
    React.createElement(motion.div, {
      variants: container, initial: "hidden", animate: "show",
      className: "flex flex-col md:flex-row gap-2 md:gap-6 items-center"
    },
      React.createElement('div', { className: "flex" },
        ['N','E','O','N'].map((char, i) =>
          React.createElement(motion.span, {
            key: `n-${i}`, variants: item,
            className: "text-6xl md:text-8xl font-black italic tracking-tighter text-white py-2",
            style: { textShadow: '0 0 20px rgba(255,255,255,0.8), 0 0 40px rgba(0, 243, 255, 0.5)' }
          }, char)
        )
      ),
      React.createElement('div', { className: "flex" },
        ['T','R','I','S'].map((char, i) =>
          React.createElement(motion.span, {
            key: `t-${i}`, variants: item,
            className: "text-6xl md:text-8xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-600 pr-4 py-2",
            style: { filter: 'drop-shadow(0 0 15px rgba(168, 85, 247, 0.6))' }
          }, char)
        )
      )
    ),
    React.createElement(motion.div, {
      initial: { width: 0 }, animate: { width: "100%" },
      transition: { delay: 1.2, duration: 0.8 },
      className: "h-1 bg-gradient-to-r from-transparent via-cyan-400 to-transparent mt-2"
    })
  );
};

// ─── MainMenu.tsx ────────────────────────────────────────────────────────────
const MainMenu = ({ onStartGame, onCreateGroup, onJoinGroup, onAcceptAnswer, peerId, answerCode, isConnected, isHost, connectionError }) => {
  const [view, setView] = useState('START');
  const [joinCode, setJoinCode] = useState('');      // guest: stringa offerta host
  const [answerPaste, setAnswerPaste] = useState(''); // host: stringa risposta guest

  const handlePlayClick = () => setView('MODES');
  const handleModeSelect = (mode) => {
    if (mode === 'ONLINE') return;
    onStartGame(mode);
  };
  const handleCopy = (text) => {
    if (text) { navigator.clipboard.writeText(text); alert("Codice copiato!"); }
  };

  const menuVariants = {
    hidden: { opacity: 0, x: -50 },
    visible: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: 50 }
  };

  const btnClass = "group relative w-64 py-4 px-6 bg-black border border-white/20 overflow-hidden hover:border-cyan-400 transition-colors duration-300";
  const btnContent = (text) => React.createElement(React.Fragment, null,
    React.createElement('div', { className: "absolute inset-0 bg-cyan-500/10 transform -translate-x-full skew-x-12 group-hover:translate-x-0 transition-transform duration-500" }),
    React.createElement('span', { className: "relative z-10 font-bold tracking-widest text-white group-hover:text-cyan-300" }, text)
  );

  return React.createElement('div', {
    className: "absolute inset-0 z-50 flex flex-col items-center justify-center bg-black p-4",
    style: { fontFamily: "'Orbitron', sans-serif" }
  },
    // Background grid
    React.createElement('div', {
      className: "absolute inset-0 pointer-events-none",
      style: { background: "linear-gradient(rgba(0,255,255,0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,255,0.05) 1px, transparent 1px)", backgroundSize: "40px 40px" }
    }),

    React.createElement(IntroLogo),

    React.createElement('div', { className: "relative z-30 h-64 w-full flex justify-center items-center" },
      React.createElement(AnimatePresence, { mode: 'wait' },

        // VIEW: START
        view === 'START' && React.createElement(motion.div, {
          key: "start", initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }
        },
          React.createElement('button', { onClick: handlePlayClick, className: btnClass }, btnContent("INITIATE_SYSTEM"))
        ),

        // VIEW: MODES
        view === 'MODES' && React.createElement(motion.div, {
          key: "modes", variants: menuVariants, initial: "hidden", animate: "visible", exit: "exit",
          className: "flex flex-col gap-4"
        },
          React.createElement('button', { onClick: () => handleModeSelect('LOCAL'), className: btnClass }, btnContent("1V1 LOCAL")),
          React.createElement('button', { onClick: () => handleModeSelect('BOT'), className: btnClass }, btnContent("VS CPU_BOT")),
          React.createElement('button', { onClick: () => setView('LOBBY_HOST'), className: btnClass }, btnContent("ONLINE MULTIPLAYER")),
          React.createElement('button', { onClick: () => setView('START'), className: "text-xs text-gray-500 hover:text-white mt-4 tracking-widest" }, '< BACK')
        ),

        // VIEW: HOST OR JOIN SELECTION
        (view === 'LOBBY_HOST' && !peerId) && React.createElement(motion.div, {
          key: "online-select", variants: menuVariants, initial: "hidden", animate: "visible", exit: "exit",
          className: "flex flex-col gap-4"
        },
          React.createElement('h3', { className: "text-white text-center mb-2 tracking-widest text-sm text-cyan-500" }, 'SELEZIONA PROTOCOLLO'),
          React.createElement('button', { onClick: () => onCreateGroup(), className: btnClass }, btnContent("CREA GRUPPO")),
          React.createElement('button', { onClick: () => setView('LOBBY_JOIN'), className: btnClass }, btnContent("UNISCITI A GRUPPO")),
          React.createElement('button', { onClick: () => setView('MODES'), className: "text-xs text-gray-500 hover:text-white mt-4 tracking-widest" }, '< BACK')
        ),

        // VIEW: LOBBY HOST — PASSO 1: mostra offerta, PASSO 2: incolla risposta guest
        (view === 'LOBBY_HOST' && peerId) && React.createElement(motion.div, {
          key: "lobby-host", variants: menuVariants, initial: "hidden", animate: "visible", exit: "exit",
          className: "flex flex-col items-center gap-4 bg-gray-900/80 p-6 rounded border border-cyan-500/30 backdrop-blur-md max-w-md w-full"
        },
          React.createElement('div', { className: "text-cyan-400 text-sm tracking-widest mb-2" }, 'PASSO 1 — Invia questo codice al tuo amico:'),
          React.createElement('div', { className: "flex gap-2 w-full" },
            React.createElement('textarea', { readOnly: true, rows: 3, value: peerId, className: "bg-black border border-gray-700 p-2 text-white font-mono text-xs flex-1 resize-none select-all outline-none" }),
            React.createElement('button', { onClick: () => handleCopy(peerId), className: "bg-cyan-900 px-3 text-cyan-200 text-xs hover:bg-cyan-700" }, 'COPY')
          ),
          React.createElement('div', { className: "text-white text-xs mt-2 mb-1" }, 'PASSO 2 — Incolla la risposta del tuo amico:'),
          React.createElement('textarea', {
            rows: 3, value: answerPaste,
            onChange: (e) => setAnswerPaste(e.target.value),
            placeholder: "Incolla qui il codice risposta...",
            className: "w-full bg-black border border-gray-600 p-2 text-white font-mono text-xs resize-none focus:border-cyan-500 outline-none"
          }),
          React.createElement('div', { className: "mt-2 flex flex-col items-center min-h-[50px] justify-center w-full" },
            isConnected
              ? React.createElement(React.Fragment, null,
                  React.createElement('div', { className: "text-green-500 font-bold mb-4" }, 'GIOCATORE CONNESSO'),
                  React.createElement('button', { onClick: () => onStartGame('ONLINE', true), className: `${btnClass} w-auto px-8` }, btnContent("AVVIA PARTITA"))
                )
              : React.createElement('button', {
                  onClick: () => onAcceptAnswer(answerPaste),
                  disabled: answerPaste.length < 10,
                  className: `${btnClass} w-full`,
                  style: { opacity: answerPaste.length < 10 ? 0.4 : 1 }
                }, btnContent("CONNETTI"))
          ),
          connectionError && React.createElement('div', { className: "text-red-500 text-xs font-bold text-center" }, connectionError),
          React.createElement('button', { onClick: () => window.location.reload(), className: "text-xs text-red-500 hover:text-red-400 mt-4" }, 'ANNULLA SESSIONE')
        ),

        // VIEW: LOBBY JOIN — PASSO 1: incolla offerta host, poi mostra risposta da rimandare
        view === 'LOBBY_JOIN' && React.createElement(motion.div, {
          key: "lobby-join", variants: menuVariants, initial: "hidden", animate: "visible", exit: "exit",
          className: "flex flex-col items-center gap-4 bg-gray-900/80 p-6 rounded border border-purple-500/30 backdrop-blur-md max-w-md w-full"
        },
          !answerCode
            ? React.createElement(React.Fragment, null,
                React.createElement('h3', { className: "text-white text-sm tracking-widest mb-2" }, 'PASSO 1 — Incolla il codice del tuo amico:'),
                React.createElement('textarea', {
                  rows: 3, value: joinCode,
                  onChange: (e) => setJoinCode(e.target.value),
                  placeholder: "Incolla il codice dell'host...",
                  className: "w-full bg-black border border-gray-600 p-2 text-white font-mono text-xs resize-none focus:border-purple-500 outline-none"
                }),
                connectionError && React.createElement('div', { className: "text-red-500 text-xs font-bold text-center" }, connectionError),
                React.createElement('button', {
                  onClick: () => onJoinGroup(joinCode),
                  disabled: joinCode.length < 10,
                  className: `${btnClass} w-full`,
                  style: { opacity: joinCode.length < 10 ? 0.5 : 1 }
                }, btnContent("GENERA RISPOSTA"))
              )
            : React.createElement(React.Fragment, null,
                React.createElement('h3', { className: "text-white text-sm tracking-widest mb-2" }, 'PASSO 2 — Invia questo codice al tuo amico:'),
                React.createElement('div', { className: "flex gap-2 w-full" },
                  React.createElement('textarea', { readOnly: true, rows: 3, value: answerCode, className: "bg-black border border-gray-700 p-2 text-white font-mono text-xs flex-1 resize-none select-all outline-none" }),
                  React.createElement('button', { onClick: () => handleCopy(answerCode), className: "bg-purple-900 px-3 text-purple-200 text-xs hover:bg-purple-700" }, 'COPY')
                ),
                isConnected
                  ? React.createElement('div', { className: "text-green-500 font-bold animate-pulse text-center mt-2" }, "CONNESSO. IN ATTESA DELL'HOST...")
                  : React.createElement('div', { className: "text-gray-500 text-xs italic text-center mt-2" }, "In attesa che l'host incolli la risposta...")
              ),
          React.createElement('button', { onClick: () => setView('LOBBY_HOST'), className: "text-xs text-gray-500 hover:text-white mt-4" }, '< BACK')
        )
      )
    ),

    React.createElement('div', { className: "absolute bottom-4 text-gray-700 text-[10px] tracking-[0.5em]" }, 'SYSTEM READY')
  );
};

// ─── App.tsx ─────────────────────────────────────────────────────────────────
function App() {
  const [inGame, setInGame] = useState(false);
  const [gameMode, setGameMode] = useState('LOCAL');
  const [myRole, setMyRole] = useState('X');

  const { createGroup, joinGroup, acceptAnswer, peerId, answerCode, isConnected, isHost, error: connectionError, connection, sendMessage } = useMultiplayer();

  const onLocalMove = (index) => {
    if (gameMode === 'ONLINE') sendMessage({ type: 'MOVE', index, player: myRole });
  };

  const game = useGameLogic({
    mode: gameMode,
    myPlayerRole: gameMode === 'ONLINE' ? myRole : undefined,
    onMoveMade: onLocalMove
  });

  useEffect(() => {
    if (connection) {
      const handleData = (data) => {
        const msg = data;
        if (msg.type === 'MOVE') game.networkMove(msg.index);
        else if (msg.type === 'RESTART') game.resetGame();
      };
      connection.on('data', handleData);
      return () => { connection.off('data', handleData); };
    }
  }, [connection, game]);

  const handleStartGame = (mode, onlineIsHost) => {
    setGameMode(mode);
    if (mode === 'ONLINE') {
      setMyRole(onlineIsHost ? 'X' : 'O');
      if (onlineIsHost) sendMessage({ type: 'PLAYER_JOINED' });
    } else {
      setMyRole('X');
    }
    setInGame(true);
    game.resetGame();
  };

  useEffect(() => {
    if (!inGame && isConnected && !isHost) {
      const handleData = (data) => {
        const msg = data;
        if (msg.type === 'PLAYER_JOINED' || msg.type === 'MOVE') {
          setGameMode('ONLINE');
          setMyRole('O');
          setInGame(true);
        }
      };
      connection?.on('data', handleData);
      return () => { connection?.off('data', handleData); };
    }
  }, [inGame, isConnected, isHost, connection]);

  const handleReset = () => {
    game.resetGame();
    if (gameMode === 'ONLINE') sendMessage({ type: 'RESTART' });
  };

  const handleExit = () => { setInGame(false); game.resetGame(); };

  return React.createElement('div', { style: { position:'fixed', top:0, left:0, width:'100%', height:'100%', backgroundColor:'#000', overflow:'hidden', userSelect:'none' } },

    !inGame && React.createElement(MainMenu, {
      onStartGame: handleStartGame,
      onCreateGroup: createGroup,
      onJoinGroup: joinGroup,
      onAcceptAnswer: acceptAnswer,
      peerId,
      answerCode,
      isConnected,
      isHost,
      connectionError
    }),

    inGame && React.createElement(React.Fragment, null,
      React.createElement('div', { className: "absolute inset-0 z-0" },
        React.createElement(GameScene, { game })
      ),
      React.createElement('div', { className: "absolute inset-0 z-10 pointer-events-none" },
        React.createElement(UIOverlay, { winner: game.winner, currentPlayer: game.currentPlayer, onReset: handleReset }),
        React.createElement('div', { className: "absolute top-4 left-4 pointer-events-auto z-50" },
          React.createElement('button', {
            onClick: handleExit,
            className: "text-gray-500 text-xs hover:text-white border border-gray-800 hover:border-white px-3 py-1 bg-black/50"
          }, 'EXIT_GAME')
        ),
        gameMode === 'ONLINE' && React.createElement('div', { className: "absolute bottom-4 left-4 text-xs font-mono text-cyan-500/50" },
          isHost ? 'HOST [X]' : 'GUEST [O]', ' :: LINK_ACTIVE'
        )
      )
    )
  );
}

const rootElement = document.getElementById('root');
if (!rootElement) throw new Error("Could not find root element to mount to");
const root = ReactDOM.createRoot(rootElement);
root.render(React.createElement(React.StrictMode, null, React.createElement(App)));
  </script>
</body>
</html>